# 背包问题（组合DP）

## 概述

容量有限的背包，最多装哪些物品，能够使得总价值最大

物品数`n`，容量为`v`，单个物品的最大数量为`s`

| 模型         | 特点                             | 时间复杂度  | 经典题目       |
| ------------ | -------------------------------- | ----------- | -------------- |
| 01背包       | 物品只能使用一次                 | `O(nv)`     | 数字组合       |
| 完全背包     | 物品能使用无限次                 | `O(nv)`     | 买书           |
| 多重背包     | 物品能使用有限次                 | `O(nvs-nv)` | 庆功会         |
| 分组背包     | 物品以物品组形式组织             | `O(nvs)`    | 金明的预算方案 |
| 二维费用背包 | 两层费用的01背包                 | `O(nv1v2)`  | 潜水员         |
| 混合背包     | 01，完全，多重背包组合           | `O(nvs-nv)` |                |
| 依赖背包     | 物品之间的依赖关系以树的形式组织 | `O(nv)`     | 选课           |
| 方案问题     | 求方案数与具体方案               |             | 数字组合       |

- **难点**

（1）多重背包的优化问题（二进制优化，单调队列优化）

（2）分组背包

（3）依赖背包

（4）体积的描述问题（不超过，恰好，至少）

## 技巧与经验

| 技巧         | 使用场景                                         | 经典题目 |
| ------------ | ------------------------------------------------ | -------- |
| 数组压缩     | 节省挑选范围索引，但是求方案和方案数大多不能节省 | 陪审团   |
| 状态压缩     | 二进制，特征信息等优化状态设计                   |          |
| 数据结构优化 | 单调队列优化决策环节                             | 硬币     |



## 题目总结

### 简单

| 模型         | 题目                             |
| ------------ | -------------------------------- |
| 01背包       | 采药，装箱，开心的金明，数字组合 |
| 完全背包     | 买书，自然数拆分                 |
| 多重背包     | 庆功会，机器分配                 |
| 分组背包     |                                  |
| 二维费用背包 | 小精灵，潜水员                   |
| 混合背包     |                                  |
| 依赖背包     |                                  |



### 复杂

| 模型         | 题目           |
| ------------ | -------------- |
| 01背包       | 能量石         |
| 完全背包     | 货币系统       |
| 多重背包     | 硬币           |
| 分组背包     | 金明的预算方案 |
| 二维费用背包 | 陪审团         |
| 混合背包     |                |
| 依赖背包     | 选课           |



## 题库

1、自然数拆分

完全背包求方案数

（1）状态表示  `f[i,j]`

集合：所有从前`i`个物品中选，且总体积**恰好**是`j`的所有选择方案的集合

属性：数量

（2）状态计算
$$
f[i][j]=f[i-1][j]+f[i][j-i]
$$


2、陪审团 

二维费用背包求方案

（1）状态表示   `f[i,j,k]`

集合：所有从前`i`个人中选择`j`个人，且差值**恰好**是`k`的所有方案的集合

属性：最大值

（2）状态计算
$$
f[i][j][k]=max(f[i-1][j][k],f[i-1][j-1][k-(p_i-d_i)]+(p_i+d_i))
$$


3、硬币

多重背包优化

二进制优化  时间超限

单调队列优化   常数时间太大，时间超限

鉴于本题的`dp`值是一个`bool`值，可以用一个数组来优化

`g[j]` 表示`j`之前最近的一个`1`的位置